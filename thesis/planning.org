* Chapters
** ONGOING Introduction
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: REVIEW
:RELWORK:  TODO
:END:

$\exists P \ldotp \phi(P) $

This chapter should:

- open the thesis with a page or two that sells the work to a general audience
(e.g., a science reporter);
- tie the work together and highlight the novel contributions;
- advertise the organization of the rest of the document.

Things to (maybe) talk about:

# Overview: ch.1, pages 7-13
- user intent
- search space
- search technique
# DSL design
- expressiveness
- choice of operators
- naturalness
- efficiency
# Program ranking
- Program speed - superopt
- Robustness - pbe
- Naturalness and readability
# Artificial intelligence
- Machine Learning (check Jha:2017:TFS)
- Explainable AI
- Reverse engineering of black-box models

Missing an explanation of why the search space is big.

Maybe rewrite the example in haskell or a similar language to improve the
typography?


Synthesis as a next-step from verification:
 - \phi{}(input, program, output)
   - fix program and input: interpretation
   - fix program and output: reverse interpretation
   - fix program: verification
   - fix input and output: synthesis

# Introduction, maybe?
In this context, the synthesis process should be \todo{reasonably fast}{explain}
in order to be useful. The synthesized programs should also be ``natural'' in
the sense that it seems like it was written by a human programmer. We also want
our programs to be readable in order for the users to able to verify it
themselves. 

% ------------------------------------------------------------------------------
% Questions left to answer?
% - Extend the motivation.
% - In practice where can this be applied (present/future)?
% - How does prog. synth. compare to other kinds of automatic programming? In
% particular, how does it compare to ML?
% - Can you give an example?
% - What does this thesis introduce? Give a summary of the work done in the rest
% of the thesis.

% Other questions that will be answered in the following sections include:
% - How to provide user intent?
% - How to solve the problem efficiently?

% ------------------------------------------------------------------------------
% Compromise:
% - reducing the scope or domain of application
% - make the synthesizers domain-specific and less general (embed the insights
%   directly into the synthesizers)

% Solutions are:
% - solver-aided programming: human provides high-level insights while the
% synthesizer takes care of the low-level details.
% - human-computer working together (interaction through active learning)

% Automating this work is good because:
% - code is correct by construction

% - sintetizadores altamente especializados e calibrados para dominios particulares
% - bugs enviados para a camada de abstraccao acima

** ONGOING Preliminaries
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Missing definitions:
- Program space
- What does it mean for a program to satisfy a specification
- Example, a set of examples, etc
- Context-free grammars
- DSL

Some background on how SMT solvers work, e.g., describe DPLL(T).

** REVIEW Background
  DEADLINE: <2019-03-13 Wed>
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

I guess, at the end of this section there should probably be a discussion
comparing the different approaches to the problem.

*** REVIEW Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** REVIEW Logical Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing reference.

***** [Ideas]
Add an example. Ideas:
- Leon
- POPL'19 Polikarpova, swap. This one is good because it can serve as an example
  for the subsection on deductive synthesis.

**** REVIEW Syntactic Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** TODO Sketching
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example.

***** TODO Component-Based Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example. Ideas:
- SyPet
- FrAngel: Also, it adds control structures to the problem

***** TODO Syntax-Guided Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example.

**** REVIEW Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** TODO Programming By Examples
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- Missing references
- Missing example

***** TODO Programming By Demonstration
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- Maybe check if there's some Gulwani paper to put here.

**** REVIEW Programs
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing example (take one from the papers).

*** REVIEW Search Techniques
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** TODO Deductive Search
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Expand on this.
Commented out because it is too simple.

References: Polikarpova:2019:SSH, Manna:1971:TAP, Green:1969:ATP

**** TODO Representation-Based Search
:PROPERTIES:
:CONTENT:  TODO
:EXAMPLES: TODO
:RELWORK:  TODO
:END:
- VSAs: motivated by inductive learning; particularly suited to pbe
  - put simply, just a DAG where every part corresponds to a valid program
  - supports learn, intersect and pick
  - encodes a possibly exponential number of programs
- Finite tree automata


**** REVIEW Enumerative Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** Top-Down Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Adicionar ref. ao facto de que estes algoritmos geralmente consideram o tamanho
das expressões que estão a gerar. Ver a overview do Gulwani. Sem dizer isso, a
descrição fica algo inconsistente com os dois algoritmos que vem a seguir.

Adicionar (possivelmente) um exemplo de um traço de execução do algoritmo.

***** Bottom-Up Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Check out references [4, 141] of Gulwani2017.

This algorithm is shown in Figure \fixme{???}{ainda tenho que produzir esta
figura}, using program size as the metric of program complexity.

***** Bidirectional Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing pseudocode.

**** REVIEW Stochastic Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** Sampling the Search Space
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** REVIEW Constraint Solving
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:
**** REVIEW Oracle-Guided Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

** ONGOING Synthesis
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

Check Brahma's contributions/limitations on Nadia's lecture 07 (page 17).

*** ONGOING Problem Description
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

- [ ] Mention that we are using _positive_ examples.
- [ ] Note that examples show constants that are not part of the input.

*** ONGOING Setwise Encoding
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

- [ ] Synthesizer program listing

**** Program Formula
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

*** ONGOING Whole Encoding
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

** ONGOING Experimental Results
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

*** REVIEW Benchmark Description

Missing computer specifications.

*** REVIEW Results

*** ONGOING Discussion

- [ ] For one example, without a ranking function for programs, the synthesizers
  returns overfitted programs
  - far fetched constants and "identity components" make everything possible
  - tricks like (Length(''), or Concat(''), etc)
  - a common theme is to combine Length and Substr plus a string constant
    containing the expected output prefixed by garbage with the length of the
    input: Substr(c0, Length(x0), Length(x0))

- [ ] Need to apply restrictions:
  - on the domain of constants: constants should not contain the output
  - on the domain of formal param,ters: index arguments to substr should
    not be the same, concat should not be applied to the empty string, length
    with constants, etc

- [X] would be interesting to check the configurations for Setwise and Whole
  where constants are provided by the user, in order to better compare with
  SyPet-User.
  - Or trying to infer the constants from the input-output examples.
  - Or separating the sketch phase from constant search phase (similar to cegis(t))

- [ ] Note that the times for the solved benchmarks are reasonably fast,
  allowing for reasonable interaction times with the user. 
- [ ] On the other hand, we do not manage to synthesize programs with many
  lines, which means.

** TODO Concluding Remarks
- [ ] At some point we have to explain which components we are considering and
  how they map to SMT. Particularly, we should explain the logics that we need,
  and whether they are decidable (preliminaries) or not.
  (https://anthonywlin.github.io/papers/popl18-replace.pdf)

- [ ] Why does a component-based approach lend itself well? (direct mapping
  between components and DSL constructs; compare this with FlashFill's
  approach).


- [ ] Explain that both encodings are independent of the components used as long
  as they can be specified in SMT

Comparison to Jha's et al. approach:

- [ ] We use a lot more components.
- [ ] More than just one type. Also, larger search space with strings that
  with bitvectors.
- [ ] We synthesize arbitrary constants that are not given as user input.
- [ ] Their program must use all components from the library exactly once.
- [ ] Our components are more complex.
- [ ] We prevent the addition of dead-code by asserting that every variable
  should be used at least once.

Fine tuning and further benchmarking is needed.

*** TODO Related Work
*** TODO Future Work
*** TODO Conclusion
* config :noexport:
#+TODO: TODO ONGOING REVIEW | DONE
#+COLUMNS: %36ITEM %7CONTENT %7RELWORK %7EXAMPLES
#+PROPERTY: CONTENT_ALL  TODO ONGOING REVIEW DONE
#+PROPERTY: EXAMPLES_ALL TODO ONGOING REVIEW DONE
#+PROPERTY: RELWORK_ALL  TODO ONGOING REVIEW DONE
