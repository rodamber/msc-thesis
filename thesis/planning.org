* Chapters
** ONGOING Introduction
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: REVIEW
:RELWORK:  TODO
:END:

$\exists P \ldotp \phi(P) $

This chapter should:

- open the thesis with a page or two that sells the work to a general audience
(e.g., a science reporter);
- tie the work together and highlight the novel contributions;
- advertise the organization of the rest of the document.

Things to (maybe) talk about:

# Overview: ch.1, pages 7-13
- user intent
- search space
- search technique
# DSL design
- expressiveness
- choice of operators
- naturalness
- efficiency
# Program ranking
- Program speed - superopt
- Robustness - pbe
- Naturalness and readability
# Artificial intelligence
- Machine Learning (check Jha:2017:TFS)
- Explainable AI
- Reverse engineering of black-box models

Missing an explanation of why the search space is big.

Maybe rewrite the example in haskell or a similar language to improve the
typography?


Synthesis as a next-step from verification:
 - \phi{}(input, program, output)
   - fix program and input: interpretation
   - fix program and output: reverse interpretation
   - fix program: verification
   - fix input and output: synthesis

# Introduction, maybe?
In this context, the synthesis process should be \todo{reasonably fast}{explain}
in order to be useful. The synthesized programs should also be ``natural'' in
the sense that it seems like it was written by a human programmer. We also want
our programs to be readable in order for the users to able to verify it
themselves. 

% ------------------------------------------------------------------------------
% Questions left to answer?
% - Extend the motivation.
% - In practice where can this be applied (present/future)?
% - How does prog. synth. compare to other kinds of automatic programming? In
% particular, how does it compare to ML?
% - Can you give an example?
% - What does this thesis introduce? Give a summary of the work done in the rest
% of the thesis.

% Other questions that will be answered in the following sections include:
% - How to provide user intent?
% - How to solve the problem efficiently?

% ------------------------------------------------------------------------------
% Compromise:
% - reducing the scope or domain of application
% - make the synthesizers domain-specific and less general (embed the insights
%   directly into the synthesizers)

% Solutions are:
% - solver-aided programming: human provides high-level insights while the
% synthesizer takes care of the low-level details.
% - human-computer working together (interaction through active learning)

% Automating this work is good because:
% - code is correct by construction

% - sintetizadores altamente especializados e calibrados para dominios particulares
% - bugs enviados para a camada de abstraccao acima

** ONGOING Preliminaries
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Missing definitions:
- Program space
- What does it mean for a program to satisfy a specification
- Example, a set of examples, etc
- Context-free grammars
- DSL

Some background on how SMT solvers work, e.g., describe DPLL(T).

** REVIEW Background
  DEADLINE: <2019-03-13 Wed>
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

I guess, at the end of this section there should probably be a discussion
comparing the different approaches to the problem.

*** REVIEW Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** REVIEW Logical Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing reference.

***** [Ideas]
Add an example. Ideas:
- Leon
- POPL'19 Polikarpova, swap. This one is good because it can serve as an example
  for the subsection on deductive synthesis.

**** REVIEW Syntactic Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** TODO Sketching
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example.

***** TODO Component-Based Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example. Ideas:
- SyPet
- FrAngel: Also, it adds control structures to the problem

***** TODO Syntax-Guided Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: REVIEW
      :RELWORK:  REVIEW
      :END:

Missing example.

**** REVIEW Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** TODO Programming By Examples
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- Missing references
- Missing example

***** TODO Programming By Demonstration
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- Maybe check if there's some Gulwani paper to put here.

**** REVIEW Programs
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing example (take one from the papers).

*** REVIEW Search Techniques
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** TODO Deductive Search
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Expand on this.
Commented out because it is too simple.

References: Polikarpova:2019:SSH, Manna:1971:TAP, Green:1969:ATP

**** TODO Representation-Based Search
:PROPERTIES:
:CONTENT:  TODO
:EXAMPLES: TODO
:RELWORK:  TODO
:END:
- VSAs: motivated by inductive learning; particularly suited to pbe
  - put simply, just a DAG where every part corresponds to a valid program
  - supports learn, intersect and pick
  - encodes a possibly exponential number of programs
- Finite tree automata


**** REVIEW Enumerative Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** Top-Down Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Adicionar ref. ao facto de que estes algoritmos geralmente consideram o tamanho
das expressões que estão a gerar. Ver a overview do Gulwani. Sem dizer isso, a
descrição fica algo inconsistente com os dois algoritmos que vem a seguir.

Adicionar (possivelmente) um exemplo de um traço de execução do algoritmo.

***** Bottom-Up Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Check out references [4, 141] of Gulwani2017.

This algorithm is shown in Figure \fixme{???}{ainda tenho que produzir esta
figura}, using program size as the metric of program complexity.

***** Bidirectional Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing pseudocode.

**** REVIEW Stochastic Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** Sampling the Search Space
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

**** REVIEW Constraint Solving
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:
**** REVIEW Oracle-Guided Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

** ONGOING Synthesis
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

Check Brahma's contributions/limitations on Nadia's lecture 07 (page 17).

*** ONGOING Problem Description
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

- [ ] Mention that we are using _positive_ examples.
- [ ] Note that examples show constants that are not part of the input.

*** ONGOING Setwise Encoding
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

- [ ] Synthesizer program listing

**** Program Formula
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

*** ONGOING Whole Encoding
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

** ONGOING Experimental Results
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

*** REVIEW Benchmark Description

Missing computer specifications.

*** TODO Results and Comparison

- calls to solvers (timeout, numero de conflictos)
- replace e undecidable
- versao em que se fixa o set de constantes

- user intent
- time
- comparing size of encodings
-- later: number of constants needed of each type

- ranking needed, especially for few examples: far fetched constants and
  "identity components" make everything possible
- substring indexes should not be the same
- constants should not contain the output
- would be interesting to check the case where constants are limited, or
  provided by the user

- we're counting the solution as 'expected' even if it's not the same program
  from the benchmark: the reasoning is that if it captures the same idea and
  generalizes, even if it is not natural, then we consider it correct.

- setwise, nonrec, e2c1, results much closer to the expected solution, although
  many times 2 examples are not enough to generalize

- we could try adding more examples (and refine them)

- there seems to be some sweet spot at 3 lines where the synth. is able to find
  programs that satisfy three examples 

- mention that while we tried to make the examples "as good as possible" ...

- [ ] Analysis of the size of the problem in function of the number of constants,
  components, arity of the components, number of examples, number of inputs,
  etc.

*** TODO Other

We tried encoding more complex functions (recursive), but...

** TODO Concluding Remarks
- [ ] At some point we have to explain which components we are considering and
  how they map to SMT. Particularly, we should explain the logics that we need,
  and whether they are decidable (preliminaries) or not.
  (https://anthonywlin.github.io/papers/popl18-replace.pdf)

- [ ] Why does a component-based approach lend itself well? (direct mapping
  between components and DSL constructs; compare this with FlashFill's
  approach).


- [ ] Explain that both encodings are independent of the components used as long
  as they can be specified in SMT

Comparison to Jha's et al. approach:

- [ ] We use a lot more components.
- [ ] More than just one type. Also, larger search space with strings that
  with bitvectors.
- [ ] We synthesize arbitrary constants that are not given as user input.
- [ ] Their program must use all components from the library exactly once.
- [ ] Our components are more complex.
- [ ] We prevent the addition of dead-code by asserting that every variable
  should be used at least once.

*** TODO Related Work
*** TODO Future Work
*** TODO Conclusion
* config :noexport:
#+TODO: TODO ONGOING REVIEW | DONE
#+COLUMNS: %36ITEM %7CONTENT %7RELWORK %7EXAMPLES
#+PROPERTY: CONTENT_ALL  TODO ONGOING REVIEW DONE
#+PROPERTY: EXAMPLES_ALL TODO ONGOING REVIEW DONE
#+PROPERTY: RELWORK_ALL  TODO ONGOING REVIEW DONE
