* Unanswered Questions
- [ ] Which SMT solver are we using? (bibliographic reference)
% In our case we are using Z3, a state-of-the-art \gls{smt} solver. It allows
% reasoning over string constraints and linear arithmetic...

- [ ] What constructs does the SMT theory for strings provide?

- [ ] Explanation of why we chose the components we chose. The problem was
  open-ended at first and was refined over time. We approach the problem in
  stages. First just a small dsl of text components. Then all of them, then If
  statements. 

* Chapters
** TODO Introduction
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: REVIEW
:RELWORK:  TODO
:END:

$\exists P \ldotp \phi(P) $

This chapter should:

- open the thesis with a page or two that sells the work to a general audience
(e.g., a science reporter);
- tie the work together and highlight the novel contributions;
- advertise the organization of the rest of the document.

Things to (maybe) talk about:

# Overview: ch.1, pages 7-13
- user intent
- search space
- search technique
# DSL design
- expressiveness
- choice of operators
- naturalness
- efficiency
# Program ranking
- Program speed - superopt
- Robustness - pbe
- Naturalness and readability
# Artificial intelligence
- Machine Learning (check Jha:2017:TFS)
- Explainable AI
- Reverse engineering of black-box models

Missing an explanation of why the search space is big.

Maybe rewrite the example in haskell or a similar language to improve the
typography?


Synthesis as a next-step from verification:
 - \phi{}(input, program, output)
   - fix program and input: interpretation
   - fix program and output: reverse interpretation
   - fix program: verification
   - fix input and output: synthesis

# Introduction, maybe?
In this context, the synthesis process should be \todo{reasonably fast}{explain}
in order to be useful. The synthesized programs should also be ``natural'' in
the sense that it seems like it was written by a human programmer. We also want
our programs to be readable in order for the users to able to verify it
themselves. 

% ------------------------------------------------------------------------------
% Questions left to answer?
% - Extend the motivation.
% - In practice where can this be applied (present/future)?
% - How does prog. synth. compare to other kinds of automatic programming? In
% particular, how does it compare to ML?
% - Can you give an example?
% - What does this thesis introduce? Give a summary of the work done in the rest
% of the thesis.

% Other questions that will be answered in the following sections include:
% - How to provide user intent?
% - How to solve the problem efficiently?

% ------------------------------------------------------------------------------
% Compromise:
% - reducing the scope or domain of application
% - make the synthesizers domain-specific and less general (embed the insights
%   directly into the synthesizers)

% Solutions are:
% - solver-aided programming: human provides high-level insights while the
% synthesizer takes care of the low-level details.
% - human-computer working together (interaction through active learning)

% Automating this work is good because:
% - code is correct by construction

% - sintetizadores altamente especializados e calibrados para dominios particulares
% - bugs enviados para a camada de abstraccao acima

** TODO Preliminaries
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Missing definitions:
- Program space
- What does it mean for a program to satisfy a specification
- Example, a set of examples, etc
- Context-free grammars
- DSL

Some background on how SMT solvers work, e.g., describe DPLL(T).

** TODO Background
  DEADLINE: <2019-03-13 Wed>
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: DONE
:RELWORK:  REVIEW
:END:

I guess, at the end of this section there should probably be a discussion
comparing the different approaches to the problem.

*** TODO Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: DONE
:RELWORK:  REVIEW
:END:

**** TODO Logical Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing reference.

***** [Ideas]
Add an example. Ideas:
- Leon
- POPL'19 Polikarpova, swap. This one is good because it can serve as an example
  for the subsection on deductive synthesis.

**** TODO Syntactic Specifications
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: TODO
:RELWORK:  REVIEW
:END:

***** TODO Sketching
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: TODO
      :RELWORK:  REVIEW
      :END:

Missing example.

***** TODO Component-Based Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: TODO
      :RELWORK:  REVIEW
      :END:

Missing example. Ideas:
- SyPet
- FrAngel: Also, it adds control structures to the problem

***** TODO Syntax-Guided Synthesis
      :PROPERTIES:
      :CONTENT:  REVIEW
      :EXAMPLES: TODO
      :RELWORK:  REVIEW
      :END:

Missing example.

**** TODO Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

***** TODO Programming By Examples
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

- Missing references
- Missing example

***** TODO Programming By Demonstration
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- Maybe check if there's some Gulwani paper to put here.

**** TODO Programs
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: TODO
:RELWORK:  REVIEW
:END:

Missing example (take one from the papers).

*** TODO Search Techniques
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: DONE
:RELWORK:  ONGOING
:END:

Missing:
- deductive search
- representation-based search (!!!)
  - VSAs: motivated by inductive learning; particularly suited to pbe
    - put simply, just a DAG where every part corresponds to a valid program
    - supports learn, intersect and pick
    - encodes a possibly exponential number of programs

**** TODO Deductive Search
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

Expand on this.
Commented out because it is too simple.

References: Polikarpova:2019:SSH, Manna:1971:TAP, Green:1969:ATP

**** TODO Enumerative Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

***** TODO Top-Down Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Adicionar ref. ao facto de que estes algoritmos geralmente consideram o tamanho
das expressões que estão a gerar. Ver a overview do Gulwani. Sem dizer isso, a
descrição fica algo inconsistente com os dois algoritmos que vem a seguir.

Adicionar (possivelmente) um exemplo de um traço de execução do algoritmo.

***** TODO Bottom-Up Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Check out references [4, 141] of Gulwani2017.

This algorithm is shown in Figure \fixme{???}{ainda tenho que produzir esta
figura}, using program size as the metric of program complexity.

***** TODO Bidirectional Tree Search
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

Missing pseudocode.

**** TODO Stochastic Search
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

Missing stuff on:

- Genetic Programming
- Neural Program Synthesis
- Graph neural networks
- ... check [[https://alexpolozov.com/blog/program-synthesis-2018/][Polozov's overview]] for work done since 2017

Missing refs: LEE_ASP_2018, DeepCoder, Ruben, for the first approach and STOKE
for the second one, for example.

***** Guiding the Search
:PROPERTIES:
:CONTENT:  TODO
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

They describe their \gls{dsl} by a \gls{cfg}.

``Our algorithm is essentially the same as the existing enumerative algorithm
except that it enumerates programs in order of likelihood instead of size.
Therefore, instead of enumerating all the smallest expressions (e.g., “.”, “-”,
x), it first proposes x + “.”, which is found only in the third iteration by the
existing enumerative search. ''

``The first key contribution of our approach is an efficient algorithm based on
A* search to enumerate programs in order of decreasing probability.''
It works with wide range of different probabilistic models. One of them is pcfg,
which takes a sentential form and returns a probability for each production rule.

``Our algorithm conceptually works on a directed weighted graph—constructed on
demand—of sentential forms derived from the given model.''

``However, as our evaluation in Section 5 shows, uniform cost search performs
poorly in practice by expanding a huge number of paths before reaching the
solution node. We address this problem by employing A* search [14] instead of
uniform cost search.''

They apply a slightly tweaked version of $A*$. The heuristic function is a
statistical model.


% LEE_ASP_2018
% DeepCoder style synthesis

***** Sampling the Search Space
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

**** TODO Constraint Solving
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

% TODO: Check out 132, 133, 134 of the overview

Examples are still missing.

Things that might be missing:

- SMTEN? PROSE?
- concept of domain separation
- Metasketching, symbolic profiling?
- Conflict-driven (example)
- Distinguishing inputs (example)
- Inductive Logic Programming (subsubsection)

**** TODO Oracle-Guided Inductive Synthesis
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: TODO
:RELWORK:  REVIEW
:END:

Example could be Jha's distinguishing inputs from the OGIS paper.

Note that there might be some ambiguity about what we mean about distinguishing
inputs depending on the context (interactivity, etc).

Figures should come at the top of the page and before the text that references
it, when possible.

Wonder if some parts are too close to the original.

*** TODO Programming by Examples
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  ONGOING
:END:

% Examples, being a kind of inductive specifications, are inherently
% \textit{ambiguous}.
% There might be multiple programs consistent with the examples, but we must find
% the \textit{intended} one (disambiguation).

Specifics of PBE. Needs cleaning.

PBE VSAs, deduction-based, inverse semantics, type-based, ambiguity, intent

** TODO Synthesis
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: ONGOING
:RELWORK:  ONGOING
:END:

*** TODO Problem Description
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- [ ] Mention that we are using _positive_ examples.
- [ ] Note that examples show constants that are not part of the input.

*** TODO Setwise Encoding
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

- [ ] Synthesizer program listing

**** Program Formula
:PROPERTIES:
:CONTENT:  REVIEW
:EXAMPLES: REVIEW
:RELWORK:  REVIEW
:END:

*** TODO Whole Encoding
:PROPERTIES:
:CONTENT:  ONGOING
:EXAMPLES: TODO
:RELWORK:  TODO
:END:

** TODO Other Approaches/Future Work
- Learning patterns from the corpus of expressions. see: https://arxiv.org/abs/1902.06349

** TODO Bibliography
   :PROPERTIES:
   :CONTENT:  ONGOING
   :END:

** TODO Discussion/Experimental Results
*** Setwise Encoding
- [ ] How to decide on the number of constants

- [ ] Explain that this encoding is independent of the components used as long
  as they can be specified in SMT

- [ ] Analysis of the size of the problem in function of the number of constants,
  components, arity of the components, number of examples, number of inputs,
  etc.

Comparison to Jha's et al. approach:

- [ ] We use a lot more components.
- [ ] More than just one type. Also, larger search space with strings that with bitvectors.
- [ ] We synthesize arbitrary constants that are not given as user input.
- [ ] Their program must use all components from the library exactly once.
- [ ] Our components are more complex (recursive).
- [ ] Separation of program enumeration and constraint solving (?)
- [ ] We prevent the addition of dead-code by asserting that every variable should
  be used at least once.

*** Other
- [ ] At some point we have to explain which components we are considering and
  how they map to SMT. Particularly, we should explain the logics that we need,
  and whether they are decidable (preliminaries) or not.
  (https://anthonywlin.github.io/papers/popl18-replace.pdf)

- [ ] Why does a component-based approach lend itself well? (direct mapping
  between components and DSL constructs; compare this with FlashFill's
  approach).

** TODO Conclusion
However, the problem specification was deliberately vague, which gave us liberty
to explore different options. In practice, this means ... (asking for user
constants, etc).

** TODO Summary

* config :noexport:
#+COLUMNS: %36ITEM %7CONTENT %7RELWORK %7EXAMPLES
#+PROPERTY: CONTENT_ALL  TODO ONGOING REVIEW DONE
#+PROPERTY: EXAMPLES_ALL TODO ONGOING REVIEW DONE
#+PROPERTY: RELWORK_ALL  TODO ONGOING REVIEW DONE
