\chapter{Introduction}
\label{chapter:introduction}

$\exists P \ldotp \phi(P) $

Program synthesis is the task of automatically generating implementations from
semantic specifications while also being efficient according to some cost metric.

Pnuelli in [Solar-Lezama ref. \#50] ``one of the most central problems in the
theory of programming''.

\textit{Holy grail}: tell the computer \textit{what to do} and let it figure out
\textit{how to do} it and not in any way, but in an efficient way (according to
some metric).

This is a hard problem. Synthesizers lack algorithmic insight and domain
expertise.

Compromise:

\begin{itemize}
\item reducing the scope or domain of application
\item make the synthesizers domain-specific and less general (embed the insights
  directly into the synthesizers)
\end{itemize}

Solutions are:

\begin{itemize}
\item solver-aided programming: human provides high-level insights while the
synthesizer takes care of the low-level details.
\item human-computer working together (interaction through active learning)
\end{itemize}



% Some kinds of specifications are:
% -

% Applications/goals are:
% -

% Automating this work is good because:
% - code is correct by construction
% - 

% % \cite{Solar-Lezama:2008}
% ``Inductive synthesis is the process of generating a program from concrete
% observations of its behavior, where an observation describes the expected
% behavior of the program on a specific input. The inductive synthesizer uses each
% new observation to refine its hypothesis about what the correct program should
% be until it converges to a solution. Inductive synthesis had its origin in the
% work by Gold [33] on language learning, and the pioneering work by Shapiro [57]
% on inductive synthesis and its application to algorithmic debugging among
% others.''


\pdffreetextcomment{Check p. 92 of the overview for the pros and cons of \gls{PBE}}
