\chapter{Introduction}
\label{chapter:introduction}

$\exists P \ldotp \phi(P) $

Program synthesis is the task of automatically generating implementations from
semantic specifications while also being efficient according to some cost metric.

Pnuelli in [Solar-Lezama ref. \#50] ``one of the most central problems in the
theory of programming''.

\textit{Holy grail}: tell the computer \textit{what to do} and let it figure out
\textit{how to do} it and not in any way, but in an efficient way (according to
some metric).

This is a hard problem. Synthesizers lack algorithmic insight and domain
expertise.

Compromise:

\begin{itemize}
\item reducing the scope or domain of application
\item make the synthesizers domain-specific and less general (embed the insights
  directly into the synthesizers)
\end{itemize}

Solutions are:

\begin{itemize}
\item solver-aided programming: human provides high-level insights while the
synthesizer takes care of the low-level details.
\item human-computer working together (interaction through active learning)
\end{itemize}



% Some kinds of specifications are:
% -

% Applications/goals are:
% -

% Automating this work is good because:
% - code is correct by construction
% - 



\pdffreetextcomment{Check p. 92 of the overview for the pros and cons of \gls{PBE}}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
