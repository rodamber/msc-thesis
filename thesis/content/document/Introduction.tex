\chapter{Introduction}
\label{chapter:introduction}

% This chapter should:
% - open the thesis with a page or two that sells the work to a general audience
% (e.g., a science reporter);
% - tie the work together and highlight the novel contributions;
% - advertise the organization of the rest of the document;

% $\exists P \ldotp \phi(P) $

\todo{Program synthesis is the problem of automatically generating
implementations from high-level specifications.}{add ref} \todo{Amir Pnuelli,
former computer scientist and Turing Award, described it as ``one of the most
central problems in the theory of programming''}{add ref}, and it has been
\todo{portrayed as one of the holy grails of computer science}{solar-lezama phd
thesis, gulwani et al overview}.

It is easy to understand why: if only we could tell the computer \textit{what to
do} and let it figure out \textit{how to do} it, the task of programming would
be so much easier!

Program synthesis is a hard problem, though. \todo{Programming is a task that is
hard for humans}{add ref 45 solar-lezama thesis} and, given its generality,
there is no reason to believe it should be any easier for computers. Computers
lack algorithmic insight and domain expertise. Moreover, the challenge is
actually twofold: we need to find out both how to tackle the intractibility of
the program space, and how to accurately capture user intent~\cite{Gulwani2017}.

% 1. explicar porque que o espaco de procura e grande

It is important to have in mind that program synthesis is not a panacea for
solving problems in computer programming. For example, while we are interested
in properties besides functional correctness, such as efficiency or
succinctness, it is impossible for program synthesis to eliminate all sources of
bugs. Particularly, it cannot solve problems originating from bad specifications
that come from a bad understanding of the problem domain.

Writing specifications is, indeed, a delicate process. This might be better
understood with a simple, non-trivial, example.

\section{Example: Sorting}
\label{sec:sorting-example}

In order to exemplify how the interaction between the user and the computer
(from now on referred to as the ``synthesizer'') might occur, let us suppose we
are interested in developing a sorting procedure, \verb|sort|, for lists of
integers.

\begin{figure}[h]
  \centering
\begin{verbatim}
sort: (xs: List) -> (xs': List)
sort([])    = []
sort(x::xs) = insert(x, sort(xs))

insert: (x: Int, xs: List Int) -> (xs': List Int)
insert(x, [])    = [x]
insert(x, y::ys) = if x <= y then (x::y::ys)
                             else y::insert(x, ys)
\end{verbatim}
  \caption{Possible implementation for a list sorting procedure.}
  \label{fig:sort-impl}
\end{figure}

The function \verb|sort| should take a list of integers as input and return it
sorted in ascending order. One approach to implement \verb|sort| is to resort to
an auxiliary function \verb|insert|, taking an element \verb|x| and a list
\verb|xs| as inputs and returning a new list \verb|xs'|, as described in
Figure~\ref{fig:sort-impl}. Assuming that \verb|xs| is sorted, \verb|insert|
guarantees that \verb|xs'| is also sorted by placing \verb|x| in the ``right
place''. It is easy to see, by induction, that sort is correctly defined.

\begin{figure}[h]
  \centering
\begin{verbatim}
isSorted: List Int -> Bool
isSorted([])       = True
isSorted([x])      = True
isSorted(x::y::ys) = x <= y and isSorted(y::ys)
\end{verbatim}
  \cprotect\caption{Predicate \verb|isSorted|. Given a list, the predicate
    outputs whether its elements are arranged in ascending order.}
  \label{fig:is-sorted-pred}
\end{figure}

\begin{figure}[h]
  \centering
\begin{verbatim}
sort: (xs: List Int) -> (xs': List Int)
sortSpec: isSorted(xs')

insert: (x: Int, xs: List Int) -> (xs': List Int)
insertSpec: isSorted(xs) ==> isSorted(xs')
\end{verbatim}
  \caption{First attempt at a specification for the sorting procedure.}
  \label{fig:sort-spec-1}
\end{figure}

Nevertheless, it would be nicer if we could just give the synthesizer a
specification of what it means for a list to be sorted and let it figure out the
implementation. For example, the synthesizer could support type signatures and
predicates as specifications, as in Figure~\ref{fig:sort-spec-1}. We could also
hint the structure of the implementation to the synthesizer by giving a
specification for another function, \verb|insert|, which we could believe to be
useful to implement \verb|sort|.

\begin{figure}[h!]
  \centering
\begin{verbatim}
sort: (xs: List Int) -> (xs': List Int)
sort(xs) = []

insert: (x: Int, xs: List Int) -> (xs': List Int)
insert(x, xs) = []
\end{verbatim}
  \cprotect\caption{First attempt at synthesizing \verb|sort|. The specification
    was not sufficiently precise and failed to capture our intent.}
  \label{fig:sort-synth-1}
\end{figure}

There is a problem, however: the synthesizer does not output a sorting
procedure! Indeed, \verb|sort| meets the specification, as an empty list is
sorted, by the definition of \verb|isSorted| (\ref{fig:is-sorted-pred}).

\begin{figure}[h!]
  \centering
\begin{verbatim}
sort: (xs: List Int) -> (xs': List Int)
sortSpec: isSorted(xs') and sameContents(xs, xs')

insert: (x: Int, xs: List Int) -> (xs': List Int)
insertSpec: isSorted(xs) ==>
  isSorted(xs') and sameContents(xs', x::xs)
\end{verbatim}
  \caption{Second attempt at a specification for the sorting procedure.}
  \label{fig:sort-spec-2}
\end{figure}

The problem is that the specification does not model our intent precisely. It
should be clear that the output \verb|xs'| should be in some way related to the
input \verb|xs|, but the current specification does not capture that relation.
We must require that \verb|xs'| has exactly the same contents as those of
\verb|xs|, meaning that every element of \verb|xs| should appear in \verb|xs'|
in the same amount. We could express that requirement as a binary predicate
\verb|sameContents| over lists and add it to specification as in
Figure~\ref{fig:sort-spec-2}. The implementation of \verb|sameContents| is left
as an exercise for the reader.

It should be clear by now why writing specifications can be tricky, even in
simple cases. What might be less clear is that the specification as it is might
still not be fully specified. There are countless other properties that we might
want our procedure to satisfy, such as stability, complexity or adaptability.

% ------------------------------------------------------------------------------
% Questions left to answer?
% - Extend the motivation.
% - In practice where can this be applied (present/future)?
% - How does prog. synth. compare to other kinds of automatic programming? In
% particular, how does it compare to ML?
% - Can you give an example?
% - What does this thesis introduce? Give a summary of the work done in the rest
% of the thesis.

% Other questions that will be answered in the following sections include:
% - How to provide user intent?
% - How to solve the problem efficiently?

% ------------------------------------------------------------------------------
% Compromise:
% - reducing the scope or domain of application
% - make the synthesizers domain-specific and less general (embed the insights
%   directly into the synthesizers)

% Solutions are:
% - solver-aided programming: human provides high-level insights while the
% synthesizer takes care of the low-level details.
% - human-computer working together (interaction through active learning)

% Automating this work is good because:
% - code is correct by construction

% - sintetizadores altamente especializados e calibrados para dominios particulares
% - bugs enviados para a camada de abstraccao acima

