\chapter{Preliminaries}
\label{chapter:preliminaries}

This chapter introduces some definitions and examples that will be useful later
on. It might be practical to just skim this chapter at first reading, and then
come back as needed.

\section{Program Synthesis}
\label{sec:program-synthesis}

Here we define the concrete problem we are trying to solve. In general, program
synthesis is the problem of finding a program that meets a given specification.
Therefore, we must understand the kind of programs we are trying to find, as
well as the kind of specifications that the system understands.

% TODO
Programs are usually defined by means of a \gls{cfg}. ...

% TODO
A specification is a way to convey intent. There are several ways to specify
which program we are interested in such as, for example, this and that. In our
case we are working in a \gls{pbe} setting, where the user explains their intent
by means of a set of input-output \textit{examples}.
% Def. of PBE and example follows

We say that a program $f$ \textit{satisfies} an input-output example
$(\mathbf{x}, y)$ if $f(\mathbf{x}) = y$. We say that a program satisfies a set
of examples if it satisfies every example in that set.

% TODO
For example, the following set of examples are satisfied by the program f = abc,
because ... . However, the program g = xyz also satisfies the examples. These
examples are, therefore, \textit{ambiguous}, and further examples are required
to disambiguate between the two programs. Ambiguity is a characteristic inherent
to the \gls{pbe} synthesis setting.

\section{Constraint Solving}
\label{sec:preliminaries-constraint-solving}

Our work includes the modeling of programs as constraints. We make use of
off-the-shelf automated constraint solvers in order to solve these constraints.
To understand how we can model our problem domain as constraints, it is useful
to know about the concepts of \gls{sat} and \gls{smt}.

% TODO Explain how these solvers are good and we leverage improvements made in
% the last decades, blah, blah, blah

% TODO Quintessential examples are n-queens and sudoku
\todo{<Insert here the definition of sat, and examples of encodings>}{}

% TODO Explain how it fits in the frame of theoretical computer science

Encoding programs in \gls{sat} can be a bit too low-level. We are encoding
domain knowledge into the domain of boolean formulas. In can be both hard for a
human to model a problem this way, ...

% TODO Encodings using strings and numbers.
% TODO Check examples in the puzzles directory of the SBV Haskell library
% https://en.wikipedia.org/wiki/Satisfiability_modulo_theories
\todo{<Insert here the definition of smt, and examples of encodings>}{}

% \section{Other Definitions}
% \label{sec:other-definitions}

% TODO DSL, Context-Free Grammar, PBE, program space
