\chapter{Preliminaries}
\label{chapter:preliminaries}

This chapter introduces some definitions and examples that will be useful later
on. It might be practical to just skim this chapter at first reading, and then
come back as needed.

\section{\Glsfmtfull{smt}}
\label{sec:smt}

Many problems in the real world can be modeled in the form of logical formulas.
Thus, it is of great interest to have access to efficient off-the-shelf
logic engines, usually called \textit{solvers}, for these formulas.
The satisfiability problem is the problem of checking if a given logical formula
has a solution.
\gls{smt} solvers check the satisfiability of first-order logic formulas with
symbols and operations drawn from \textit{theories}, such as the theory of
uninterpreted functions, the theory of strings, or the theory of linear integer
arithmetic.
\gls{smt} solvers have seen a multitude of applications, particularly in
problems from artificial intelligence and formal methods, such as program
synthesis, or verification.
This section gives a short introduction to \gls{smt}, and is based on the
chapter on \gls{smt} of the Handbook of Satisfiability~\cite{Biere:2009:HSV}.

\subsection{Syntax of \gls{smt} Formulas}
\label{sec:smt-syntax}

Here we define the language of well-formed \gls{smt} formulas. Formulas are
composed of symbols and logical connectives over those symbols.

\begin{definition}[Signature]
  A signature $\Sigma{} = \Sigma{}^F \cup{} \Sigma{}^P$ is a set of
  ($\Sigma{}$-)symbols.
  $\Sigma{}^F$ is the set of \textit{function} symbols, and $\Sigma{}^P$ is the
  set of \textit{predicate} symbols.
  Each symbol has an associated arity. A zero-arity symbol $x$ is called a
  \textit{constant} symbol if $x \in \Sigma{}^F$, and is called a
  \textit{propositional} symbol if $x \in \Sigma{}^P$.
\end{definition}

\begin{definition}[Terms and Formulas]
  The concepts of \textit{Term} and \textit{formula} are defined in terms of
  each other. A ($\Sigma{}$-)term $t$ is an expression of the form:
  %
  \[t ::= c \OR f(t_1,\ldots,t_n) \OR ite(\phi{}, t_0, t_1)\]
  %
  where $c \in \Sigma{}^F$ with arity 0, $f \in \Sigma{}^F$ with arity
  $n > 0$, and $\phi{}$ is a formula.
  A ($\Sigma{}$-)formula $\phi{}$ is an expression of the form:
  %
  \[\phi{} ::= A
    \OR p(t_1,\ldots,t_n)
    \OR t_0 = t_1
    \OR \bot{}
    \OR \top{}
    \OR \neg{}\phi{}
    \OR \phi{}_0 \rightarrow{} \phi{}_1
    \OR \phi{}_0 \leftrightarrow{} \phi{}_1
    \OR \phi{}_0 \land{} \phi{}_1
    \OR \phi{}_0 \lor{} \phi{}_1
    \OR (\exists{}x\ldotp\phi{}_0)
    \OR (\forall{}x\ldotp\phi{}_0)
  \]
  %
  where $A \in \Sigma{}^P$ with arity 0, and $p \in \Sigma{}^P$ with arity
  $n > 0$.
\end{definition}

% \begin{definition}[Atom]
%   An atom is a formula of the form $A$, $p(t_1,\ldots,t_n)$, $t_0 = t_1$,
%   $\bot{}$, or $\top{}$.
% \end{definition}

% \begin{definition}[Literal]
%   A literal is an atom or its negation.
% \end{definition}

% \begin{definition}[Clause]
%   A clause is a disjunction of literals.
% \end{definition}

% \begin{definition}[\gls{cnf}]
%   A \gls{cnf} formula is a conjunction of clauses.
% \end{definition}

\subsection{Semantics of \gls{smt} Formulas}
\label{sec:smt-semantics}

In this section we explore how \gls{smt} formulas are given meaning.

\begin{definition}[Model]
  Given a signature $\Sigma{}$, a ($\Sigma{}$-)\textit{model} $\mathcal{A}$ for
  $\Sigma{}$ is a tuple $(A, (\_)^{\mathcal{A}})$ where:
  %
  \begin{enumerate}
  \item $A$, called the \textit{universe} of the model, is a non-empty set;
  \item $(\_)^{\mathcal{A}}$ is a function with domain $\Sigma{}$, mapping:
    \begin{itemize}
    \item each constant symbol $a \in \Sigma{}^F$ to an element
      $a^{\mathcal{A}} \in A$;
    \item each function symbol $f \in \Sigma{}^F$ with arity $n > 0$ to a total
      function $f^{\mathcal{A}}\colon A^n \to A$;
    \item each propositional symbol $B \in \Sigma{}^P$ to an element
      $B^{\mathcal{A}} \in \{\mathbf{true}, \mathbf{false}\}$;
    \item and each predicate symbol $p \in \Sigma{}^P$ with arity $n > 0$ to a
      total predicate $p^{\mathcal{A}}\colon A^n \to \{\mathbf{true},
      \mathbf{false}\}$.
    \end{itemize}
  \end{enumerate}
\end{definition}

\begin{definition}[Interpretation]
  Given a model $\mathcal{A} = (A, (\_)^{\mathcal{A}})$ for a signature
  $\Sigma{}$, an \textit{interpretation} for $\mathcal{A}$ is a function, also
  called $(\_)^{\mathcal{A}}$, mapping each $\Sigma{}$-term $t$ to an element
  $t^{\mathcal{A}}\in A$ and each $\Sigma{}$-formula $\phi{}$ to an element
  $\phi{}^{\mathcal{A}}\in \{\mathbf{true}, \mathbf{false}\}$, in the following
  manner:
  %
  \begin{enumerate}
  \item $f(t_1,\ldots,t_n)^{\mathcal{A}}$ is mapped to
    $f^{\mathcal{A}}(t_1^{\mathcal{A}},\ldots,t_n^{\mathcal{A}})$;
  \item $p(t_1,\ldots,t_n)^{\mathcal{A}}$ is mapped to
    $p^{\mathcal{A}}(t_1^{\mathcal{A}},\ldots,t_n^{\mathcal{A}})$;
  \item $ite(\phi{}, t_1, t_2)^{\mathcal{A}}$ is equal to $t_1^{\mathcal{A}}$ if
    $\phi{}^{\mathcal{A}}$ is $\mathbf{true}$, and equal to $t_2^{\mathcal{A}}$
    otherwise;
  \item $\bot{}^{\mathcal{A}}$ is mapped to $\mathbf{false}$;
  \item $\top{}^{\mathcal{A}}$ is mapped to $\mathbf{true}$;
  \item $(t_1 = t_2)$ is mapped to $\mathbf{true}$ if
    $t_1^{\mathcal{A}}$ is equal to $ t_2^{\mathcal{A}}$, and is mapped to
    $\mathbf{false}$ otherwise.
  \item $\Sigma$-symbols are mapped according to the mapping of the model just
    as before.
  \end{enumerate}
\end{definition}

\begin{definition}[Satisfiability]
  Given a model $\mathcal{A} = (A, (\_)^{\mathcal{A}})$ for a signature
  $\Sigma{}$, the model $\mathcal{A}$ is said to satisfy a $\Sigma{}$-formula
  $\phi{}$ if and only if $\phi{}^{\mathcal{A}}$ is $\mathbf{true}$.
  The formula $\phi{}$ is said to be \textit{satisfiable}.
\end{definition}

% \todo{Typically we are not interested in just any model...}{give motivation for
%   introducing theories}

% Typically, we are only interested in certain interpretations of the symbols of
% the signature $\Sigma{}$.
% For example, if we have the formula $\exists{} x\ldotp (name(x) =
% \text{``$Socrates$''}) \land Man(x)$.

\begin{definition}[Theory]\label{def:theory}
  Given a signature $\Sigma{}$, a ($\Sigma{}$-)theory $\mathcal{T}$ for
  $\Sigma{}$ is a non-empty, and possibly infinite, set of models for $\Sigma{}$.
\end{definition}

\begin{definition}[$\mathcal{T}$-Satisfiability]
  Given a signature $\Sigma{}$ and a $\Sigma{}$-theory $\mathcal{T}$, a
  $\Sigma{}$-formula $\phi{}$ is said to be $\mathcal{T}$-\textit{satisfiable}
  if and only if (at least) one of the models of $\mathcal{T}$ satisfies
  $\phi{}$.
\end{definition}

% \todo{Motivation for uninterpreted symbols}{}

% \begin{definition}[Uninterpreted Symbols]
%   Given a signature $\Sigma{}$ and a $\Sigma{}$-formula $\phi{}$, an
%   \textit{uninterpreted} symbol is any symbol in $\phi{}$ that is not in
%   $\Sigma{}$.
% \end{definition}

% % \todo{How uninterpreted symbols are accommodated in the definitions}{}

% \begin{definition}[Expanded Signature]
%   Given a signature $\Sigma{}$, an expanded signature of $\Sigma{}$ is any
%   superset $\Sigma{}'$ of $\Sigma{}$.
% \end{definition}

% \begin{definition}[Expanded Model]
%   Given a model $\mathcal{A}$ for a signature $\Sigma{}$, an expanded model
%   $\mathcal{A}'$ of $\mathcal{A}$ is any model for an expanded signature
%   $\Sigma{}'$ of $\Sigma{}$ with the same
%   universe as $\mathcal{A}$, and whose interpretation agrees with the
%   interpretation of $\mathcal{A}$ on the symbols of $\Sigma{}$.
% \end{definition}

% \begin{definition}[Expanded Theory]
%   Given a signature $\Sigma{}$ and a $\Sigma{}$-theory $\mathcal{T}$, an
%   expanded theory $\mathcal{T}'$ of $\mathcal{T}$ is any theory for an expanded
%   signature $\Sigma{}'$ of $\Sigma{}$ composed solely of expanded models of the
%   models of $\mathcal{T}$.
% \end{definition}

% \begin{definition}[SMT Problem]
%   Given a signature $\Sigma{}$ and a $\Sigma{}$-theory $\mathcal{T}$, the
%   \gls{smt} problem is the problem of determining the
%   $\mathcal{T}'$-satisfiability of $\Sigma{}'$-formulas, where $\Sigma{}'$ and
%   $\mathcal{T}'$ are arbitrary expansions of $\Sigma{}$ and $\mathcal{T}$,
%   respectively.
% \end{definition}

\begin{definition}[SMT Problem]
  Given a signature $\Sigma{}$ and a $\Sigma{}$-theory $\mathcal{T}$, the
  \gls{smt} problem is the problem of determining the
  $\mathcal{T}$-satisfiability of $\Sigma{}$-formulas.
\end{definition}

% ------------------------------------------------------------------------------

% \section{Program Synthesis}
% \label{sec:program-synthesis}

% Here we define the concrete problem we are trying to solve. In general, program
% synthesis is the problem of finding a program that meets a given specification.
% Therefore, we must understand the kind of programs we are trying to find, as
% well as the kind of specifications that the system understands.

% % TODO
% Programs are usually defined by means of a \gls{cfg}. ...

% % TODO
% A specification is a way to convey intent. There are several ways to specify
% which program we are interested in such as, for example, this and that. In our
% case we are working in a \gls{pbe} setting, where the user explains their intent
% by means of a set of input-output \textit{examples}.
% % Def. of PBE and example follows

% We say that a program $f$ \textit{satisfies} an input-output example
% $(\mathbf{x}, y)$ if $f(\mathbf{x}) = y$. We say that a program satisfies a set
% of examples if it satisfies every example in that set.

% % TODO
% For example, the following set of examples are satisfied by the program f = abc,
% because ... . However, the program g = xyz also satisfies the examples. These
% examples are, therefore, \textit{ambiguous}, and further examples are required
% to disambiguate between the two programs. Ambiguity is a characteristic inherent
% to the \gls{pbe} synthesis setting.

% \section{Constraint Solving}
% \label{sec:preliminaries-constraint-solving}

% Our work includes the modeling of programs as constraints. We make use of
% off-the-shelf automated constraint solvers in order to solve these constraints.
% To understand how we can model our problem domain as constraints, it is useful
% to know about the concepts of \gls{sat} and \gls{smt}.

% % TODO Explain how these solvers are good and we leverage improvements made in
% % the last decades, blah, blah, blah

% % TODO Quintessential examples are n-queens and sudoku
% \todo{<Insert here the definition of sat, and examples of encodings>}{}

% % TODO Explain how it fits in the frame of theoretical computer science

% Encoding programs in \gls{sat} can be a bit too low-level. We are encoding
% domain knowledge into the domain of boolean formulas. In can be both hard for a
% human to model a problem this way, ...

% % TODO Encodings using strings and numbers.
% % TODO Check examples in the puzzles directory of the SBV Haskell library
% % https://en.wikipedia.org/wiki/Satisfiability_modulo_theories
% \todo{<Insert here the definition of smt, and examples of encodings>}{}

