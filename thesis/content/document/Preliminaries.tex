\chapter{Preliminaries}
\label{chapter:preliminaries}

This chapter introduces some definitions and examples that will be useful later
on. It might be practical to just skim this chapter at first reading, and then
come back as needed.

\section{Program Synthesis}
\label{sec:program-synthesis}

Here we define the concrete problem we are trying to solve. In general, program
synthesis is the problem of finding a program that meets a given specification.
Therefore, we must understand the kind of programs we are trying to find, as
well as the kind of specifications that the system understands.

% TODO
\todo{We are working in the context of OutSystems'...}{concept of readability,
  usability, etc. That the programs are outsystems' expressions, etc.}

The programs we are interested in are OutSystems'
expressions\footnote{\url{https://success.outsystems.com/Documentation/11/Reference/OutSystems_Language/Logic/Expressions}}.

In the context of this work, we can think OutSystems' expressions as a simple
functional language of operands and operators that compose themselves to create
a pure, stateless, pipeline-like program. This means that OutSystems'
expressions do not have side-effects, like printing to the screen, or writing to
a database.

% TODO What is an operator? What is and operand?
% https://success.outsystems.com/Documentation/11/Reference/OutSystems_Language/Logic/Expressions

% TODO Example of an outsystems' expression
The library of builtin expressions includes functions that manipulate data types
such a text, or dates. \todo{Listing x includes examples of outsystems
  expressions. These do y and z.}{}

% TODO Explain how it fits in the context of service studio and how it interacts
% with other features (like being able to manipulate structures and lists).
This language of expressions fits on ...


\section{Constraint Solving}
\label{sec:preliminaries-constraint-solving}

Our work includes the modeling of programs as constraints. We make use of
off-the-shelf automated constraint solvers in order to solve these constraints.
To understand how we can model our problem domain as constraints, it is useful
to know about the concepts of \gls{SAT} and \gls{SMT}.

% TODO Explain how these solvers are good and we leverage improvements made in
% the last decades, blah, blah, blah

% TODO Quintessential examples are n-queens and sudoku
\todo{<Insert here the definition of SAT, and examples of encodings>}{}

% TODO Explain how it fits in the frame of theoretical computer science

Encoding programs in SAT can be a bit too low-level. We are encoding domain
knowledge into the domain of boolean formulas. In can be both hard for a human
to model a problem this way, ...

% TODO Encodings using strings and numbers.
% TODO Check examples in the puzzles directory of the SBV Haskell library
% https://en.wikipedia.org/wiki/Satisfiability_modulo_theories
\todo{<Insert here the definition of SMT, and examples of encodings>}{}

% \section{Other Definitions}
% \label{sec:other-definitions}

% TODO DSL, Context-Free Grammar, PBE, program space
