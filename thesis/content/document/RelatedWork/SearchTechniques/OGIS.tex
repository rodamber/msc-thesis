\subsection{Oracle-Guided Inductive Synthesis}
\label{sec:ogis}

\textit{\Gls{ogis}} is an approach to program synthesis where the synthesizer is
split into two components: the \textit{learner} and the \textit{oracle}. The two
components communicate in an iterative \textit{query/response} cycle, as shown
in \fixme{Figure}{missing figure}. The learner implements the search strategy to
find the program and is parameterized by some form of program specification
and/or syntactic bias (see~\ref{sec:specifications}). The usefulness of the
oracle is defined by the type of queries it can handle and the properties of its
responses. The characteristics of these components are typically imposed by the
\todo{application}{give an example}.

\fixme{Falta aqui uma figura a representar o sistema OGIS para substituir a
  figura~\protect\ref{fig:cegis}.}{}

\begin{figure}
  \centering
  \begin{tikzpicture}
    [semithick, >=stealth, auto,
    component/.style={rectangle, draw, rounded corners, text width=4cm,
      align=center, minimum size=1.5cm}]

    \node [component] (S)                   {Solver \\ (\textit   {search} component)};
    \node [component] (V)  [right=4cm of S] {Verifier \\ (\textit {validation} component)}
      ([yshift=0.2cm]S.east) edge [->] node        {Candidate program $P$}  ([yshift=0.2cm]V.west)
      ([yshift=-.2cm]S.east) edge [<-] node [swap] {Counterexample $x^{-}$} ([yshift=-.2cm]V.west);

    \node [above=of S] {Search space}
      edge [->] (S);
    \node [above=of V] {Specification $\phi$}
      edge [->] (V);

    \node [below=of S] {\xmark{} Fail}
      edge [<-] (S);
    \node [below=of V] {\checkmark{} Success}
      edge [<-] (V);
  \end{tikzpicture}
  \caption{Counterexample-guided inductive synthesis. Adapted from
    ~\protect\citeauthor{Gulwani2017}~\protect\cite{Gulwani2017}.}

  \label{fig:cegis}
\end{figure}


Typical queries and response types are some of the following:

\begin{itemize}
\item \textit{Membership queries}, where given an I/O example $x$ the oracle
  responds with the answer to whether $x$ is positive or not.
\item \textit{Positive (resp. negative) witness queries}, where the oracle
  responds with a positive (resp. negative) I/O example, if it can find any, or
  $\bot$ otherwise.
\item \textit{Counterexample queries}, where given a candidate program $p$ the
  oracle responds with a positive I/O counterexample that $p$ does not satisfy,
  if it can find any, or $\bot$ otherwise.
\item \textit{Correctness queries}, where given a candidate program $p$ the
  oracle responds with the answer to whether $p$ is correct or not. If it is not,
  the oracle responds with a positive I/O counterexample.
\item \textit{Verification queries}, where given program $p$ and specification
  $\phi$ the oracle responds with the answer to whether $p$ satisfies $\phi$ or
  not, or $\bot$ if it cannot find the answer.
\item \textit{Distinguishing input queries}, where given program $p$ and set $X$
  of I/O examples that $p$ \todo{satisfies}{did I define what satisfying a set of
    examples means?} the oracle responds with a new program $p'$ and a
  counterexample $x$ to $p$ that $p'$ satisfies along with all the other
  examples in $X$.
\end{itemize}
% FIXME: Is this ^^^ too close to the original?

An \gls{ogis} system responding to counterexample queries corresponds to the
\textit{\gls{cegis}} system, introduced by Solar-Lezama \cite{Solar-Lezama:2008}
in the context of the SKETCH synthesizer. Correctness oracles are more powerful
than counterexample oracles because they are guaranteed to return a
counterexample if the program is not correct, where the counterexample oracles
might not.

The concept of \gls{ogis} and distinguishing inputs were introduced by Jha et.
al \cite{Jha:2017:TFS} as a generalization of \gls{cegis} when they applied
this idea in a example-based synthesizer in order to deobfuscate malware and to
generate bit-manipulating programs. Jha et al. further developed this idea by
presenting a new theoretical framework for inductive synthesis
\cite{Jha:2017:TFS}.

\fixme{Aqui tenho dúvida se devo ou não colocar pseudocódigo do algoritmo deles
(Como na figura 3.3. da overview) Ou se já é aprofundar demais. Note que eles
\textbf{não} fazem queries ao utilizador}{}

In general, the higher the capabilities of the oracles, the more expensive they
are to run. Distinguishing oracles are (typically) not as strong as
counterexample or correctness oracles as the returned counterexample is not
necessarily positive. To see why they might by such effectives tools we can
recur to the \todo{Bounded Observation Hypothesis}{caps?} \fixme{first
introduced}{as far as I know} by Solar-Lezama \cite{Solar-Lezama:2008}, which
asserts that ``an implementation that works correctly for the common case and
for all the different corner cases is likely to work correctly for all inputs.''

In a setting of \todo{interactive program synthesis}{defined?} we could see the
users take the role of the oracles. However, the interesting cases are the ones
where the ratio between the amount of work the users are given and the
information given to the synthesizer is maximized. A system that frequently
queries the users for correctness checks would probably feel very cumbersome. On
the other hand, a system that queries for membership or positiveness checks
might be more realistic, as usually the \todo{users}{sometimes I refer to the
user in the singular and sometimes not. I probably should be paying more
attention to this.} have an idea of what sort of examples fit their desired
model.

