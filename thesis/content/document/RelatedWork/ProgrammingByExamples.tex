\section{Programming by Examples}
\label{sec:pbe}

\pdfmarkupcomment[color=red]{This section needs rewriting.}{}

\pdfmargincomment{I wonder if most of this paragraph should not be in the
introduction instead.}
\ac{PBE} is an instance of the program synthesis problem where the specification
is given by \ac{IO} examples.
\pdfmarkupcomment[color=yellow]{Examples are generally easier to read and write
than other kinds of specifications, such as logical formulas or program
sketches}{Not entirely correct; it depends on the application}.
Typically they are preferred due to their ease of use, especially by
non-programmers.
However, sometimes it can be cumbersome or even impractical to specify the
examples concretely, particularly if they are too large.
\pdfmargincomment{Add an example here} \ac{PBE} can then be relaxed to allow
incomplete outputs.
On the other hand, \pdfmarkupcomment[color=yellow]{inputs are tipically easier
to come by.}{Why? And is this necessary?}

\begin{itemize}
\item applications (data wrangling [FlashFill, Morpheus])
\end{itemize}

\subsection{Version Space Algebra}

\pdfmarkupcomment[color=red]{The chapter structure might be following too much the survey.}{}

\pdfmarkupcomment[color=red]{I don't know this should be here, this seems to be applicable to other kinds of program synthesis problems}{}

\ac{VSA} is a data structure that allows for an efficient representation of a
very large space of program sets by exploiting sharing among program
subexpressions. \pdfmarkupcomment[color=yellow]{It also allows for efficient
operations on these sets such as:} {list and explain the operations}.

\pdfmargincomment{expand on this}
They were introduced by Lau et al. in \cite{Lau:2000} and applied in ... for ...
In particular, they were used in FlashFill...

% \ac{VSA} is a data structure which allows for a \pdfcomment{on the size of
% what?} polynomial space representation of sets of programs of exponential size.

\subsection{Specialized Search Techniques}
\label{sec:pbe-search-techniques}

\pdfmarkupcomment[color=yellow]{Typically, they fall inside a
\textit{divide-and-conquer} deductive approach. }{rewrite this}


\begin{itemize}
\item inverse semantics (constraint backpropagation) used in FlashFill
(traditionally using \ac{VSA}): backpropagates constraints down the grammar of
the \ac{DSL}; may not be feasible or can be expensive in practice (?);
\item type-theoretic interpretation of \ac{PBE} and refinement types used, resp.,
in Myth and Synquid. Can be very efficient when the \ac{DSL} carries expressive
refinements (when ill-typed terms outnumber the well-typed ones).
\end{itemize}

\subsection{Disambiguation}
\label{sec:resolving-ambiguity}

Examples are, fundamentally, an \textit{under-specification}. There might be
multiple consistent programs, but we must find the \textit{desired} one.

\subsubsection{Ranking}

\pdfmargincomment{rewrite the whole section} By ranking the set of programs
consistent with examples according to their likelihood (better score, more
likely to be the desired program). Requires domain expertise, it is
time-consuming and error-prone, and is fragile because it depends too much on
the underlying \ac{DSL}. \pdfmarkupcomment[color=yellow]{There have been
approaches to define such functions manually} {refs on page 110 of the survey},
but a more automated approach was proposed by Singh and Gulwani in
\cite{Singh:ranking:2015}. There, they present a supervised machine learning
approach for learning a \pdfmarkupcomment[color=yellow]{hierarchical ranking
function }{explain what hierarchical means and their relation to VSAs} which
they applied to \pdfmarkupcomment[color=yellow]{FlashFill}{have we referenced
flash fill before?}. Some challenges of this are:
\begin{itemize}
\item needs large set of labeled training data;
\item needs appropriate machine learning models and cost functions;
  % basically needs ML expertise, duh
\item the ranking function should allow for efficient identification of the
  top-ranked program.
\end{itemize}

\pdfmargincomment{expand on this} A key insight is that in program synthesis it
is sufficient to rank any correct program higher than all incorrect programs.

\subsubsection{Active Learning}

Active learning is an interactive approach between the user and the synthesizer.
Typically, this happens by asking the user for (a small set of) additional
\ac{IO} examples. \pdfmarkupcomment[color=yellow]{Another idea}{verify this},
introduced by Jha et al.\cite{Jha:oracle:2010}, works by finding a \ref{explain
what this is}\textit{distinguishing input} and query the user what the expected
output should be for it. This way it is possible to disambiguate between two
programs whose outputs differ on that particular input.

Other types of active learning exist such as:
\begin{itemize}
\item displaying the program to the user;
\item paraphrasing the program in natural language;
\item accepting negative examples; 
  % isto e algo que nao parece ter sido muito explorado
\end{itemize}

\pdfmarkupcomment[color=yellow]{Ambiguity resolution may depend a lot on corner case coverage.}{expand}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Thesis"
%%% End:
