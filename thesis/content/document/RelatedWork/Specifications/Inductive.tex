\subsection{Inductive Synthesis}
\label{sec:inductive}

% FIXME: Few references

Inductive synthesis is an instance of the program synthesis problem where the
constraints are under-specified. Sometimes the domain we want to model is
complex enough that a complete specification could be as hard to produce as the
program itself. In other cases, we might want the synthesizer to be as easy and
intuitive to use as possible for users with a myriad of different backgrounds.

\subsubsection{Programming By Examples}

\Gls{pbe} is an instance of inductive synthesis where the specification is given
by \gls{io} examples that the desired program must satisfy. Explicitly giving
examples can be preferred due to their ease of use, especially by
non-programmers, when compared to more technical kinds of specification, such as
logical formulas. The examples may either be \todo{positive}{explain me; example
ref} or \todo{negative}{explain me; example ref}. More generally, given some
(implicit) \gls{io} pair, we may include asserting properties of the output
instead of specifying it completely \cite{Gulwani2017, Polozov:2015:FFI}. This
can be helpful if it is impractical or impossible to write the output concretely,
e.g., if it is infinite.

\subsubsection{Programming By Demonstration}

% Watch What I Do â€“ Programming by Demonstration

In \gls{pbd} the user does not write a specification \textit{per se}; instead the
synthesizer actively records user actions on concrete examples using them to
infer the intended program. The program must be general enough to be used
with different inputs. \gls{pbd} can be seen as a refinement of \gls{pbe} that
considers an entire execution trace (i.e., step-by-step instructions of the
program behavior on a given input) instead of a single \gls{io} example. It
depicts \textit{how} to achieve the corresponding output instead of just
specifying \textit{what} it should be.

Though the concept of \gls{pbd} is easy to understand, the task of the user can
be tedious and time-consuming. Therefore, the synthesizer must be able to infer
the intended program from a small set of user demonstrations. Ideally, it would
also be able to interact effectively and receive feedback from the user.
However, the concept might also be interesting when applied to non-interactive
contexts, such as \textit{reverse engineering}.

Lau et al. applied \gls{pbd} to the text-editing domain by implementing
SMARTedit, a system that induces repetitive text-editing programs from as few as
one or two examples. The system resembles familiar keystroke-based macro
interfaces, but it generalizes to a more robust program that is likely to work
in more situations \cite{Lau2003}. They have also presented a language-neutral
framework and an implementation of a system that learns procedural programs from
just 5.1 traces on average \cite{Lau:traces:2003}.

% % \cite{Solar-Lezama:2008}
% ``Inductive synthesis is the process of generating a program from concrete
% observations of its behavior, where an observation describes the expected
% behavior of the program on a specific input. The inductive synthesizer uses each
% new observation to refine its hypothesis about what the correct program should
% be until it converges to a solution. Inductive synthesis had its origin in the
% work by Gold [33] on language learning, and the pioneering work by Shapiro [57]
% on inductive synthesis and its application to algorithmic debugging among
% others.''

% \pdffreetextcomment{Check p. 92 of the overview for the pros and cons of \gls{PBE}}
