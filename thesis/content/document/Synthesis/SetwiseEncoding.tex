\section{Setwise Encoding}
\label{sec:setwise-encoding}

Because OutSystems expressions are composed of self-contained pure functions,
this synthesis problem fits nicely in the component-based synthesis
paradigm~\ref{sec:components}. Therefore, assume we are given a \textit{library}
of base components $F$ that the synthesizer can use in order to compose the
programs. These components will be builtin functions drawn from the OutSystems
library, or combinations of them. Each component can take a finite number of
inputs and return exactly one output. More formally, a component $f \in F$ is
represented by an expression $\phi{}_f$ that specifies how its input parameters
$P_f$ relate to its return value $r_f$.

We can see from the previous examples that OutSystems expressions can also
include constant literals, like \lstinline{" "}, or \lstinline{0}. These could
have be given as input, but we would like them to be figured out automatically
by the synthesizer. Ignoring well-typedness, an OutSystems expression is a
tree-like program whose form can be succintly described using a \gls{cfg}:

\[S \rightarrow f(S, ..., S) \OR x \OR c\]

\noindent
where $f \in F$, $x \in I$, and $c \in C$, where $I$ and $C$ are the set of
inputs of the program, and the set of constant literals in the OutSystems
language, respectively.

\begin{figure}
  \begin{lstlisting}[frame=tlrb]
    prog(name, prefix):
      c0 = " "
      c1 = 0
      r1 = Index(name, c0, c1)
      r2 = Substr(name, c1, r1)
      r3 = Concat(prefix, r2)
  \end{lstlisting}
\caption{\gls{ssa} representation of the program from
    Example~\ref{ex:first-name}. The last variable, \lstinline{r3}, is assumed
    here to be the return value of the program.}
\label{fig:first-name-ssa}
\end{figure}

It is useful to reason about OutSystems expressions in another representation,
called \gls{ssa} form. A program in \gls{ssa} form is a line program where every
variable is assigned exactly once and defined before it is used. For example,
the program from Example~\ref{ex:first-name} could be written in \gls{ssa} form
as shown in Listing~\ref{fig:first-name-ssa}. The body of a program in this
format can be described succinctly with the following \gls{cfg}:

\[S \to ID = c \OR ID = f(x_1, ..., x_n) \OR S;S\]

\noindent
$ID$ stands for an identifier in the OutSystems language. The non-terminal $S$
represents a line in the program. A line is an assignment of a variable to a
constant literal $c$ or to the return value of a component $f$ on inputs $x_1,
..., x_n$. As long as the program is well-typed, an input to a component can
be one of the inputs of the program, or variable defined in a preceding line.
Thus, the general structure of a program in \gls{ssa} form is a sequence of
assignments.

The approach described in this section is based on
\citeauthor{Jha:oracle:2010}'s program encoding. The idea is to encode the
program space in a formula. The formula is then constrained further in order to
encode only those programs that satisfy the input-output examples. A solution to
the formula can then be decoded back yielding a program that satisfies the set
of examples.

\begin{figure}
  \centering
  \begin{tikzpicture}
    [semithick, >=stealth, auto,
     rectangular/.style={rectangle, draw, rounded corners, text width=4cm,
       align=center, minimum size=1.5cm},
     spherical/.style={circle, draw, text width=2cm, align=center}]

    \node [rectangular] (S)  {Enumerator};
    \node [left=1.5cm of S, align=center] (I) {Examples}
      edge [->] (S);
    \node [below=of S, align=center] {Program $p$\\or Fail}
      edge [<-] (S);
    \node [spherical] (V)  [right=5cm of S] {Solver}
      ([yshift=0.2cm]S.east) edge [->, bend left]  node [align=center]      {Components subset\\+ examples}     ([yshift=0.2cm]V.west)
      ([yshift=-.2cm]S.east) edge [<-, bend right] node [swap,align=center] {SAT + Model\\or UNSAT\\or UNKNOWN} ([yshift=-.2cm]V.west);
  \end{tikzpicture}

  \caption{Diagram of the synthesizer.}
  \label{fig:synth-setwise}
\end{figure}

The synthesizer (Figure~\ref{fig:synth-setwise}) follows the \gls{ogis} model,
described in Section~\ref{sec:ogis}. It has a learner part and an oracle part,
which will call here the \textit{enumerator} and the \textit{solver},
respectively.

The enumerator receives the set of input-output examples as input, and is
parameterized by the library of components. The enumerator is responsible for
drawing a subset of components from the library. The components are drawn by
trying all sets of combinations (with replacement) in order of increasing size.
It then passes these components to the solver, along with the input-output
examples, and queries whether there is any program made only of those components
that satisfies the examples. There is the additional restriction that the
program must use each of the components in the query exactly once.

The solver works by encoding the query into an \gls{smt} formula, and uses an
automated SMT solver to check for satisfiability. The SMT solver might or might
not be able to solve the formula. If the formula is satisfiable, the solver
responds to the enumerator with SAT and a solution (called a \textit{model}) to
that formula. If not, it responds UNSAT or UNKNOWN, depending on whether the
formula is unsatisfiable or the SMT solver could not verify its satisfiability,
respectively.

The procedure keeps going in a loop until the enumerator receives SAT from the
solver. The enumerator then decodes the model into an actual program, which is
then returned.

\subsection{Program Formula}
\label{sec:program-formula}

Let us take the program from Listing~\ref{fig:first-name-ssa} as a running
example in order to understand how, given the examples and a set of components,
we can construct a formula whose model can be decoded into a program that
satisfies the examples. This program is good because it is a small, non-trivial
program, which uses non-input constant variables (\lstinline{" "} and
\lstinline{0}), and whose components have different return types.

In order to encode the space of valid programs, the solver has to decide
\begin{enumerate*}[(1)]
\item how many constant variables to create and which values to assign them,
\item in which order the components appear in the program, and
\item which \textit{actual} values to pass to the \textit{formal} parameters of
  each component.
\end{enumerate*}

For instance, Figure~\ref{fig:other-valid-programs} shows two other valid
programs using the components \lstinline{Index}, \lstinline{Substr}, and
\lstinline{Concat}. The program on the left does actually satisfy the sole
input-output example of Example~\ref{ex:first-name}, altough it does not
generalize. It does so by switching the order of the components, and using one
more variable than program~\ref{fig:first-name-ssa}. The program on the right,
however, does not satisfy the example because the values passed to
\lstinline{Concat} are reversed.

\begin{figure}
\noindent
\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[frame=tlrb]{Name}
    prog(name, prefix):
      c0 = " "
      c1 = 4
      c2 = 0
      r1 = Concat(prefix, name)
      r2 = Index(r1, c0, c1)
      r3 = Substr(r2, r1, c1)
  \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[frame=tlrb]{Name}
    prog(name, prefix):
      c0 = " "
      c1 = 0
      r1 = Index(name, c0, c1)
      r2 = Substr(name, c1, r1)
      r3 = Concat(r2, prefix)
\end{lstlisting}
\end{minipage}
\caption{Two other valid programs using the components \lstinline{Index},
  \lstinline{Substr}, and \lstinline{Concat}.}
\label{fig:other-valid-programs}
\end{figure}

In order to encode the program we need variables in the formula to model several
entities:
\begin{enumerate*}[(1)]
\item the input variables to the program;
\item the constant variables;
\item the formal parameters of each component;
\item the return variables of all components;
\item the output variable of the program; and
\item the \textit{connections} between the variables, that specify which
  variables are passed to the formal parameters of each component.
\end{enumerate*}
Thus, we have a set $I$ of input variables, a set $C$ of constant variables, a
set $P$ of the formal parameters of all components, a set $R$ of the return
variables of all components, and a variable $o$, the output variable of the
program. We will denote the formal parameter variables and return variable of
component $f$ by $P_f$ and $r_f$ , respectively. Also, we will use $F'$ to refer
to the components available to the solver (in this case, \lstinline{Index},
\lstinline{Substr}, and \lstinline{Concat} --- recall that $F$ is used to denote
the library of all components).
For program~\ref{fig:first-name-ssa} this would mean $I = \{name, prefix\}$,
$C = \{c_0, c_1\}$, and $R = \{r_1, r_2, r_3\}$. We would also have
$P = P_{Index} \cup P_{Substr} \cup P_{Concat}$, with
$P_{Index} = \{p_{11}$, $p_{12}$, $p_{13}\}$,
$P_{Substr} = \{p_{21}$, $p_{22}$, $p_{23}\}$, and
$P_{Concat} = \{p_{31}$, $p_{32}\}$.

\subsubsection{Well-Formedness Constraint}
\label{sec:wfp-constraint}

To encode the connections, we require a set $L$ of integer-valued
\textit{location} variables $l_x$ for each variable $x \in I \cup C \cup P \cup
R \cup \{o\}$. Intuitively, if $x$ is the return variable of component $f$, then
$l_x$ is the line number where $f$ appears in the program. If $x$ is a formal
parameter of some component, then $l_x$ is the line number where the actual
parameter is defined. In practice, each variable in $I$ is assigned a line
number from $1$ to $|I|$ (in the obvious way), variables in $C$ are assigned
a number from $|I| + 1$ to $C$, and the output variable $\{o\}$ is assigned the
line number $|I| + |C|$ (the last line). The locations of variables in $R$ range
from $|I| + |C| + 1$ to $|I| + |C| + |R|$. The location of each formal parameter
$x \in P$ ranges from $|I| + 1$ up to the location of its corresponding
component.
For program~\ref{fig:first-name-ssa} we would have
$l_{name} = 1$, $l_{prefix} = 2$,
$l_{c_0} = 3$, $l_{c_1} = 4$,
and $l_o = 7$.
The range constraints are
$4 \leq l_x \leq 7$ for $x \in R$,
$1 \leq l_x \leq 4$ for $x \in P_{Index}$,
$1 \leq l_x \leq 5$ for $x \in P_{Substr}$, and
$1 \leq l_x \leq 6$ for $x \in P_{Concat}$.
In general, we can capture these constraints with the following formula:

\[
  \psi{}_{\mathtt{range}} =
  \bigwedge_{f \in F'} (|I| + |C| + 1 \leq l_{r_f} \leq |I| + |C| + |R|)
  \wedge \bigwedge_{f \in F'}\bigwedge_{p \in P_f} (1 \leq l_p \leq l_{r_f})
\]

The locations of the variables $x \in I \cup C \cup \{o\}$ are known as soon as
we decide how many constant variables the program will have at its disposal
(which will be explained later). The objective is then to find an assignment to
the variables $x \in P \cup R$. These give us all the information we need to
decode back the program. For program~\ref{fig:first-name-ssa} we have $l_{r_1} =
5$, $l_{r_2} = 6$, $l_{r_3} = 7$; $l_{p_{11}} = 1$, $l_{p_{12}} = 3$,
$l_{p_{13}} = 4$; $l_{p_{21}} = 1$, $l_{p_{22}} = 4$, $l_{p_{23}} = 5$; and
$l_{p_{31}} = 2$, $l_{p_{32}} = 6$. Because the program has two inputs, we need
to subtract two to the location variables to get the ``corresponding line
numbers''. This means, for example, that \lstinline{Index}, \lstinline{Substr},
and \lstinline{Concat} appear on lines 3, 4 and 5, respectively, and so on.

We need a few more constraints in order to encode the space of well-formed
programs. First, no two components should have the same location. Thus,
we have $l_{r_1} \neq l_{r_2} \neq l_{r_3}$. In the general case:

\[
  \psi{}_{\mathtt{rloc}} =
  \bigwedge_{\substack{r_1, r_2 \in R\\ r_1 \not\equiv r_2}} (l_{r_1} \neq l_{r_2}) 
\]

\noindent
Second, the program must be well-typed, so the location of each formal parameter
$x \in P$ should differ from the location of any $y \in I \cup C \cup R$ whose
type does not match with $x$. In the same vein, only components whose return
value has the same type as the output may appear in the last line. These
constraints can be written in the following way:

\[
  \psi{}_{\mathtt{tloc}} =
  \bigwedge_{p \in P}\bigwedge_{\substack{x \in I \cup C \cup R \\ type(p) \neq type(x)}} (l_p \neq l_x)
  \wedge \bigwedge_{\substack{r \in R \\ type(r) \neq type(o)}} (l_r \neq l_o)
\]

Combining formulas $\psi{}_{\mathtt{range}}$, $\psi{}_{\mathtt{tloc}}$, and
$\psi{}_{\mathtt{tloc}}$ we get the full program well-formedness contraint:

\[
  \psi{}_{\mathtt{wfp}}(I, C, P, R) =
  \psi{}_{\mathtt{range}} \wedge \psi{}_{\mathtt{tloc}} \wedge \psi{}_{\mathtt{tloc}}
\]


\subsubsection{Functional Constraint}
\label{sec:functional-constraint}


% Variables whose location variables are equal should share the same value. 


Semantics:

\begin{align*}
  \phi{}_{spec} &= \bigwedge_{f \in F} \phi{}_f (I_f, o_f) \\
  \phi{}_{flow} &= \bigwedge_{p \in P}\bigwedge_{\substack{x \in I \cup C \cup R \\ kind(p) \neq kind(x)}} (l_p = l_x \implies p = x)
\end{align*}

All inputs used:

\[ \phi{}_{in} = \bigwedge_{i \in I}\bigvee_{p \in P}(l_i = l_p) \]

All outputs used:

\begin{align*}
  \phi{}_{out} &= \bigwedge_{f \in F}\bigvee_{p \in P - P_f}(l_f = l_p) \\
               &\vee \bigwedge_{f \in F} (l_f = l_o)
\end{align*}

Constrain the length of string constants:

\[
  \phi{}_{len} = \bigwedge_{\substack{c \in C \\ kind(c) = string}} len(c) \leq 5
\]

Extra:

\[ \phi{}_{extra} = \phi{}_{in} \wedge \phi{}_{out} \wedge \phi{}_{len} \]

Formula for a single run of a program:

\begin{align*}
  \phi{}_{prog} = \exists P,R\ldotp (\phi{}_{wfp} \wedge \phi{}_{spec} \wedge
  \phi{}_{flow} \wedge \phi{}_{extra})
\end{align*}

The full formula:

\[
  \Phi{} = \exists L\ldotp \bigwedge_{(I, o) \in E}\phi{}_{prog}
\]

We could also try:

\[
  \Phi{} = \exists L\ldotp \forall (I, o) \in E \ldotp \phi{}_{prog}
\]

\[
  \Phi{} = \exists L\ldotp \forall I, o \ldotp (I, o) \in E \implies \phi{}_{prog}
\]



% TODO Concrete example of the encoding of a program