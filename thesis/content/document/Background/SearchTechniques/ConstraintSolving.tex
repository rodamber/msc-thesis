\subsection{Constraint Solving}
\label{sec:constraint-solving}

Another approach to program synthesis is to reduce the problem to that of
constraint solving by the use of off-the-shelf automated constraint
solvers~\cite{Shi:2019:FCS,Feng:2018:PSU,Feng:2017:CST,Feng:2017:CSC,Solar-Lezama:2008,Jha:oracle:2010}
(typically SAT or SMT solvers).

One idea is to encode the specification in a logical constraint whose solution
corresponds to the desired program. \citeauthor{Gulwani2017} illustrate this
idea nicely with an example~\cite{Gulwani2017} which we adapt here.
Suppose our programs are composed of operations over two input bitvectors, $x$
and $y$ of length eight:

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{assets/constraint-solving-example.png}
  \caption{FIXME: This example is a placeholder and should be adapted.}
\end{figure}

We consider an expression to be the input variable $x$ or an 8-bit constant. A
program consists of additions and multiplications between expressions, or of
shift left/right operations over an expression by a constant.

Imagine we are interested in a program that \todo{<insert interesting bit
  twiddling hack>}{check Hacker's Delight}. In the theory of
\todo{bitvectors}{missing ref}, the program we are interested in can be encoded
by the formula \todo{<insert formula here>}{add formula correspondent to the
hack}. To find the program we can write the constraints in the SMT-LIB format
and feed them to an SMT solver:

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{assets/constraint-solving-smtlib.png}
  \caption{FIXME: This example is a placeholder and should be adapted.}
\end{figure}

This example shows an end-to-end constraint solving approach to program
synthesis. However, enconding the problem this way can sometimes be non-trivial
or time-consuming. This idea led to the appearance of the concept of
\textit{solver-aided programming}, where programming languages are enlarged with
high-level constructs that give the user access to synthesis without having to
deal with the constraint solvers directly.

For example, \citeauthor{Gulwani2017} describe the SKETCH system as a ``compiler
[that] relies on a SAT solver to materialize some language constructs''.
ROSETTE~\cite{Torlak:2013:GSL} is a framework for developing solver-aided
programming languages embedded in Racket that provides constructs not only for
synthesis, but also for verification, debugging and angelic execution.
