\section{Programming by Examples}
\label{sec:pbe}

\begin{itemize}
\item applications (data wrangling [FlashFill, Morpheus])
\end{itemize}

\subsection{Specialized Search Techniques}
\label{sec:pbe-search-techniques}

\pdfmarkupcomment[color=yellow]{Typically, they fall inside a
\textit{divide-and-conquer} deductive approach. }{rewrite this}

\begin{itemize}
\item inverse semantics (constraint backpropagation) used in FlashFill
(traditionally using \glspl{vsa}): backpropagates constraints down the grammar of
the \gls{dsl}; may not be feasible or can be expensive in practice (?);
\item type-theoretic interpretation of \gls{pbe} and refinement types used, resp.,
in Myth and Synquid. Can be very efficient when the \gls{dsl} carries expressive
refinements (when ill-typed terms outnumber the well-typed ones).
\end{itemize}

\subsection{Disambiguation}
\label{sec:resolving-ambiguity}

Examples are, fundamentally, an \textit{under-specification}. There might be
multiple consistent programs, but we must find the \textit{desired} one.

\subsubsection{Ranking}

\pdfmargincomment{rewrite the whole section} By ranking the set of programs
consistent with examples according to their likelihood (better score, more
likely to be the desired program). Requires domain expertise, it is
time-consuming and error-prone, and is fragile because it depends too much on
the underlying \gls{dsl}. \pdfmarkupcomment[color=yellow]{There have been
approaches to define such functions manually} {refs on page 110 of the survey},
but a more automated approach was proposed by Singh and Gulwani in
\cite{Singh:ranking:2015}. There, they present a supervised machine learning
approach for learning a \pdfmarkupcomment[color=yellow]{hierarchical ranking
function }{explain what hierarchical means and their relation to VSAs} which
they applied to \pdfmarkupcomment[color=yellow]{FlashFill}{have we referenced
flash fill before?}. Some challenges of this are:
\begin{itemize}
\item needs large set of labeled training data;
\item needs appropriate machine learning models and cost functions;
  % basically needs ML expertise, duh
\item the ranking function should allow for efficient identification of the
  top-ranked program.
\end{itemize}

\pdfmargincomment{expand on this} A key insight is that in program synthesis it
is sufficient to rank any correct program higher than all incorrect programs.

\subsubsection{Active Learning}

Active learning is an interactive approach between the user and the synthesizer.
Typically, this happens by asking the user for (a small set of) additional
\gls{io} examples. \pdfmarkupcomment[color=yellow]{Another idea}{verify this},
introduced by Jha et al.\cite{Jha:oracle:2010}, works by finding a
\todo{\protect\textit{distinguishing input}}{explain what this is}
and query the user what the expected output should be for it. This way it is
possible to disambiguate between two programs whose outputs differ on that
particular input.

Other types of active learning exist such as:
\begin{itemize}
\item displaying the program to the user;
\item paraphrasing the program in natural language;
\item accepting negative examples; 
  % isto e algo que nao parece ter sido muito explorado
\end{itemize}

\pdfmarkupcomment[color=yellow]{Ambiguity resolution may depend a lot on corner case coverage.}{expand}

\todo{Negative examples.}{\cite{Frankle:2016:EST}}
